<html>

<head>
	<title>Assignment II</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>

</head>

<body>
	<script src="libs/three.min.js"></script>
	<script src="libs/dat.gui.min.js"></script>
	<script src="libs/stats.min.js"></script>
	<script src="libs/OBJLoader.js"></script>
	<script src="libs/OrbitControls.js"></script>

	<script type="text/x-glsl" id="vertex">		
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			attribute vec4 tangent;
			varying vec3 vTangent;			
			varying vec3 vBitangent;
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				vNormal = normalMatrix * normal;
				vec3 objectTangent = vec3( tangent.xyz );
				vec3 transformedTangent = normalMatrix * objectTangent;
				vTangent = normalize( transformedTangent );
				vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
				uVv = uv;
				gl_Position = projectionMatrix * vPos;
			}
		</script>
	<script type="text/x-glsl" id="fragment">
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
				varying vec3 vTangent;
				varying vec3 vBitangent;

				uniform vec3 pointLightPosition; 
				uniform vec3 pointLightPosition2;
				uniform vec3 pointLightPosition3;
				uniform vec3 clight;
				uniform vec3 ambientLight;
				uniform sampler2D roughnessMap;
				uniform sampler2D diffuseMap;
				uniform sampler2D normalMap;
				uniform sampler2D aoMap;
				uniform vec2 textureRepeat;

											
				vec3 cdiff;
				vec3 cspec;
				float roughness;
				const float PI = 3.14159;

				vec3 FSchlick(float lDoth) {
					return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
				}
	
				float DGGX(float nDoth, float alpha) {
					float alpha2 = alpha*alpha;
					float d = nDoth*nDoth*(alpha2-1.0)+1.0;
					return (  alpha2 / (PI*d*d));
				}
	
				float G1(float dotProduct, float k) {
					return (dotProduct / (dotProduct*(1.0-k) + k) );
				}
	
				float GSmith(float nDotv, float nDotl) {
						float k = roughness*roughness;
						return G1(nDotl,k)*G1(nDotv,k);
				}

				void main() {
					//luce in world space
					vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );	
					vec3 l = normalize(lPosition.xyz - vPosition.xyz);

					//variabili per poi calcolare la n da usare con AO
					vec3 normal = normalize( vNormal );
					vec3 tangent = normalize( vTangent );
					vec3 bitangent = normalize( vBitangent );
					mat3 vTBN = mat3( tangent, bitangent, normal );
					vec3 mapN = texture2D( normalMap, uVv ).xyz * 2.0 - 1.0;
					vec3 n = normalize( vTBN * mapN );

					vec3 v = normalize( -vPosition);
					vec3 h = normalize( v + l);
					
					float nDotl = max(dot( n, l ),0.000001);
					float lDoth = max(dot( l, h ),0.000001);
					float nDoth = max(dot( n, h ),0.000001);
					float vDoth = max(dot( v, h ),0.000001);
					float nDotv = max(dot( n, v ),0.000001);					

					//cdiff e cspec dalle texture	
					cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
					cspec = texture2D( diffuseMap, uVv*textureRepeat ).rgb;	//al posto di diffuseMap ci va specularMap ma siccome non ce l'ho ho messo quella
					//in sRGB, linearizzo
					cdiff = pow( cdiff, vec3(2.2));					
					cspec = pow( cspec, vec3(2.2));
					//roughness
					roughness = texture2D( roughnessMap, uVv*textureRepeat).r;

					vec3 fresnel = FSchlick(lDoth);
					vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);

					//radiance con AO
					vec3 outRadiance = PI* clight * nDotl * BRDF + ambientLight*cdiff*texture2D( aoMap, uVv ).xyz;
					
					// gamma encode the final value
					gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
					
										
					
				}
		</script>

	<script>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		var controls = new THREE.OrbitControls(camera);

		//environment map
		var path = 'textures/cubemap/';
		var format = '.png	';
		var textureCube = new THREE.CubeTextureLoader().load([
			path + 'px' + format, path + 'nx' + format,
			path + 'py' + format, path + 'ny' + format,
			path + 'pz' + format, path + 'nz' + format
		]);
		scene.background = textureCube;

		//luci
		var lightParameters = {
			red: 1.0,
			green: 1.0,
			blue: 1.0,
			intensity: 1.0
		}	

		var ambientLightParameters = {
			red: 0.2,
			green: 0.2,
			blue: 0.2,
			intensity: 1.0,
		}

		//texture
		var textureParameters = {
				material: "Marble_Tiles_001_",
				repeatS: 1.0,
				repeatT: 1.0,
			}		
		
		//propriet√† materiale	
		var diffuseMap = loadTexture( "textures/diesel/Marble_Tiles_001_basecolor.jpg" );
		var normalMap = loadTexture( "textures/diesel/Marble_Tiles_001_normal.jpg" );
		var displacementMap = loadTexture( "textures/diesel/Marble_Tiles_001_height.jpg" );
		var aoMap = loadTexture( "textures/diesel/Marble_Tiles_001_ambientOcclusion.jpg" );
		var roughnessMap = loadTexture( "textures/diesel/Marble_Tiles_001_roughness.jpg" );
		
		var uniforms = {			
			clight: { type: "v3", value: new THREE.Vector3() },
			ambientLight:	{ type: "v3", value: new THREE.Vector3() },

			pointLightPosition: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

			diffuseMap: { type: "t", value: diffuseMap },
			normalMap: { type: "t", value: normalMap },
			displacementMap: { type: "t", value: displacementMap },			
			aoMap: { type: "t", value: aoMap },
			roughnessMap: { type: "t", value: roughnessMap },			
			textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) }
		};
		vs = document.getElementById("vertex").textContent;
		fs = document.getElementById("fragment").textContent;

		//luce 1 (dx)			
		var lightMesh = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh.position.set(10.0, 10.0, 0.0);
		uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
		scene.add(lightMesh);
		//luce 2 (sx)
		var lightMesh2 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh2.position.set(-10.0, 10.0, 0.0);
		uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x, lightMesh2.position.y, lightMesh2.position.z);
		scene.add(lightMesh2);
		//luce 3 (top)
		var lightMesh3 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh3.position.set(0.0, 13.0, -7.0);
		uniforms.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x, lightMesh3.position.y, lightMesh3.position.z);
		scene.add(lightMesh3);

		var ourMaterial = new THREE.ShaderMaterial({ 
				uniforms: uniforms, 
				vertexShader: vs, 
				fragmentShader: fs 
			});
		ourMaterial.vertexTangents = true;
		ourMaterial.needsUpdate = true;

		//carico oggetto
		var loader = new THREE.OBJLoader();
		var seduta;
		var struttura;
		var gambe;
		var sedia = new THREE.Object3D()
	
		loader.load('models/sedia.obj', function (object) {							
			gambe = object.children[2];
			struttura = object.children[1];
			seduta = object.children[0];		
			
			seduta.material = ourMaterial;
			struttura.material = ourMaterial;
			gambe.material = ourMaterial;

			sedia.add(struttura);
			sedia.add(seduta);
			sedia.add(gambe);
			scene.add(sedia);
			console.log(sedia);
		});

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		document.body.appendChild(stats.domElement);
		camera.position.z = 30;

		function loadTexture(file) {
				var texture = new THREE.TextureLoader().load( file , function ( texture ) {
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.anisotropy = renderer.getMaxAnisotropy();
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    			  	texture.offset.set( 0, 0 );
					texture.needsUpdate = true;
					render();
				} )
				return texture;
		}


		function init(){
			ourMaterial.needsUpdate = true;
		}

		function render() {
			requestAnimationFrame(render);
			stats.update();
			updateUniforms();
			renderer.render(scene, camera);
		}
		function updateUniforms() {			
			uniforms.clight.value = new THREE.Vector3
			(
				lightParameters.red * lightParameters.intensity,
				lightParameters.green * lightParameters.intensity,
				lightParameters.blue * lightParameters.intensity
			);
			uniforms.ambientLight.value = new THREE.Vector3(
				ambientLightParameters.red * ambientLightParameters.intensity,
				ambientLightParameters.green * ambientLightParameters.intensity,
				ambientLightParameters.blue * ambientLightParameters.intensity
			);
			uniforms.textureRepeat.value = new THREE.Vector2( textureParameters.repeatS, textureParameters.repeatT);
			
			uniforms.diffuseMap.value = diffuseMap;
			uniforms.normalMap.value = normalMap;
			uniforms.displacementMap.value = displacementMap;
			uniforms.aoMap.value = aoMap;
			uniforms.roughnessMap.value = roughnessMap;
		}
		init();
		render();
	</script>
</body>
</html>