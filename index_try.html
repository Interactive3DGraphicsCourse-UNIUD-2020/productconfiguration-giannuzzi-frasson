<html>

<head>
	<title>Assignment II</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>

</head>

<body>
	<script src="libs/three.min.js"></script>
	<script src="libs/stats.min.js"></script>
	<script src="libs/OBJLoader.js"></script>
	<script src="libs/OrbitControls.js"></script>

	<script type="text/x-glsl" id="vertex">
		varying vec3 vNormal;
		varying vec3 vPosition;
		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			gl_Position = projectionMatrix * vPos;
		}
	</script>
<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vPosition;
			uniform vec3 pointLightPosition; 
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;
			uniform vec3 clight;
			uniform vec3 cdiff;
			uniform vec3 cspec;
			uniform float roughness;
			const float PI = 3.14159;
			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}
			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}
			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}
			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}
			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );
				vec3 v = normalize( -vPosition);  
				float nDotl = max(dot( n, l ),0.0);
				vec3 h = normalize( v + l);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 n2 = normalize( vNormal );  
				vec3 h2 = normalize( v + l2);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float nDotl2 = max(dot( n2, l2 ),0.0);	
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
				vec3 n3 = normalize( vNormal );  
				float nDotl3 = max(dot( n3, l3 ),0.0);
				vec3 h3 = normalize( v + l3);
				float lDoth3 = max(dot( l3, h3 ),0.000001);		
				float nDoth3 = max(dot( n, h3 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);
				
				vec3 specularBRDF = FSchlick(lDoth)*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);
				vec3 specularBRDF2 = FSchlick(lDoth2)*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
					(4.0*nDotl2*nDotv);
				vec3 specularBRDF3 = FSchlick(lDoth3)*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
					(4.0*nDotl3*nDotv); 

				//vec3 outRadiance = (clight * nDotl * cdiff) + (clight * nDotl2 * cdiff) + (clight * nDotl3 * cdiff);					
				vec3 outRadiance = (PI* clight * nDotl * specularBRDF) + 
					(PI* clight * nDotl2 * specularBRDF2) +
					(PI* clight * nDotl3 * specularBRDF3) ;
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
	</script>

	<script>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		var renderer = new THREE.WebGLRenderer();
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;;
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		var controls = new THREE.OrbitControls(camera);

		var geometry_plane = new THREE.PlaneGeometry(200, 200, 32);
		var material_plane = new THREE.MeshPhongMaterial({ color: 0xb0b0b0, side: THREE.DoubleSide, });
		var plane = new THREE.Mesh(geometry_plane, material_plane);
		plane.rotation.x = 90 * Math.PI / 180;
		plane.receiveShadow = true;
		scene.add(plane);

				//luci
				var lightParameters = {
			red: 1.0,
			green: 1.0,
			blue: 1.0,
			intensity: 0.7
		}
		var cdiff = {
			red: 0.7,
			green: 0.0,
			blue: 0.0,
		}
		
		var uniforms = {
			cdiff: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition3: { type: "v3", value: new THREE.Vector3() },
			clight: { type: "v3", value: new THREE.Vector3() },
		};

		vs = document.getElementById("vertex").textContent;
		fs = document.getElementById("fragment").textContent;
		/*
		//luce 1 (dx)			
		var lightMesh = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh.position.set(10.0, 10.0, 0.0);
		uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
		scene.add(lightMesh);
		//luce 2 (sx)
		var lightMesh2 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh2.position.set(-10.0, 10.0, 0.0);
		uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x, lightMesh2.position.y, lightMesh2.position.z);
		scene.add(lightMesh2);
		//luce 3 (top)
		var lightMesh3 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }));
		lightMesh3.position.set(0.0, 13.0, -7.0);
		uniforms.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x, lightMesh3.position.y, lightMesh3.position.z);
		scene.add(lightMesh3);
		*/ 
		//environment map
		var path = 'textures/yokohama/';
		var format = '.jpg	';
		var textureCube = new THREE.CubeTextureLoader().load([
			path + 'posx' + format, path + 'negx' + format,
			path + 'posy' + format, path + 'negy' + format,
			path + 'posz' + format, path + 'negz' + format
		]);
		scene.background = textureCube;

		//carico oggetto
		var loader = new THREE.OBJLoader();
		var seduta;
		var struttura;
		var gambe;
		var sedia = new THREE.Object3D()

		var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
		scene.add(ambientLight);

		//luce 1 (dx) 	PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )
		var light = new THREE.PointLight(0xffffff, 2.5, 20, 2);
		light.position.set(10.0, 10.0, 0.0);
		light.castShadow = true;
		light.shadow.camera.near = 0.1;
		light.shadow.camera.far = 25;
		scene.add(light);

		//luce 2 (sx) 
		var light2 = new THREE.PointLight(0xffffff, 2, 20, 2);
		light2.position.set(10.0, 10.0, 0.0);
		light2.castShadow = true;
		light2.shadow.camera.near = 0.1;
		light2.shadow.camera.far = 25;
		scene.add(light2);
		//luce 3 (top) 
		var light3 = new THREE.PointLight(0xffffff, 2, 20, 2);
		light3.position.set(0.0, 13.0, -7.0);
		light3.castShadow = true;
		light3.shadow.camera.near = 0.1;
		light3.shadow.camera.far = 25;
		scene.add(light3);

		loader.load('models/sedia.obj', function (object) {
			//object.envMap = textureCube;				
			gambe = object.children[2];
			struttura = object.children[1];
			seduta = object.children[0];

			//texture				
			//var textureFabric = new THREE.TextureLoader().load('textures/diesel/fabric_bump.jpg');
			//textureFabric.wrapS = textureFabric.wrapT = THREE.RepeatWrapping;
			//textureFabric.repeat.set(1, 1);
			//texture				
			var texture = new THREE.TextureLoader().load('textures/diesel/Quartz_001_COLOR.jpg');
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(0.5, 1);
			//displacement
			var displacement = new THREE.TextureLoader().load('textures/diesel/Quartz_001_DISP.png');
			displacement.wrapS = displacement.wrapT = THREE.RepeatWrapping;
			displacement.repeat.set(4, 4);
			//normale
			var normale = new THREE.TextureLoader().load('textures/diesel/Quartz_001_NORM.jpg');
			normale.wrapS = normale.wrapT = THREE.RepeatWrapping;
			normale.repeat.set(4, 4);
			//occlusion
			var ao = new THREE.TextureLoader().load('textures/diesel/Quartz_001_OCC.jpg');
			ao.wrapS = ao.wrapT = THREE.RepeatWrapping;
			ao.repeat.set(4, 4);
			//roughness
			var roughness = new THREE.TextureLoader().load('textures/diesel/Quartz_001_ROUGH.jpg');
			roughness.wrapS = roughness.wrapT = THREE.RepeatWrapping;
			roughness.repeat.set(4, 4);
			//applicazione texture
			seduta.material = new THREE.MeshPhongMaterial({ color: 0xffffff, needsUpdate: true, shininess: 1, specular: 0x0 });
			struttura.material = new THREE.MeshPhongMaterial({ color: 0xffffff, needsUpdate: true});
			gambe.material = new THREE.MeshPhongMaterial({ color: 0xffffff, map: texture, needsUpdate: true });
			
			//fine test
			/*
			
			//OLD
			ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
			seduta.material = ourMaterial;
			struttura.material = ourMaterial;
			gambe.material = ourMaterial;
			*/

			struttura.castShadow = true;
			struttura.receiveShadow = true;

			sedia.add(struttura);
			seduta.castShadow = true;
			seduta.receiveShadow = true;

			sedia.add(seduta);
			gambe.castShadow = true;
			gambe.receiveShadow = true;

			sedia.add(gambe);
			sedia.castShadow = true;
			sedia.receiveShadow = true;
			scene.add(sedia);
			console.log(sedia);
		});


		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		document.body.appendChild(stats.domElement);
		camera.position.set(10, 20, 20);
		camera.lookAt(sedia.position);

		function render() {
			requestAnimationFrame(render);
			stats.update();
			renderer.render(scene, camera);
		}
		render();
	</script>
</body>

</html>